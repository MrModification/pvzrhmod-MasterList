name: Build Mod Index

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */5 * * *" 

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Build mod index
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          node << 'EOF'
          const fs = require("fs");

          const GH_API = "https://api.github.com";
          const TOPIC = "pvz-rh-mod";
          const PER_PAGE = 100;

          const token = process.env.GITHUB_TOKEN;
          const webhook = process.env.DISCORD_WEBHOOK;

          function ghFetch(url) {
            const headers = {
              "Accept": "application/vnd.github+json",
              "User-Agent": "pvz-rh-mod-indexer",
            };
            if (token) headers["Authorization"] = `Bearer ${token}`;
            return fetch(url, { headers });
          }

          async function getAllReposWithTopic(topic) {
            const repos = [];
            let page = 1;
            const seen = new Set();

            while (true) {
              const url = `${GH_API}/search/repositories?q=topic:${encodeURIComponent(topic)}&per_page=${PER_PAGE}&page=${page}`;
              const res = await ghFetch(url);
              if (!res.ok) break;

              const data = await res.json();
              if (!data.items || data.items.length === 0) break;

              for (const repo of data.items) {
                const key = `${repo.owner.login}/${repo.name}`;
                if (seen.has(key)) continue;
                seen.add(key);
                repos.push(repo);
              }

              if (data.items.length < PER_PAGE) break;
              page++;
            }

            return repos;
          }

          async function fetchRawFile(owner, repo, branch, path) {
            const url = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
            const res = await fetch(url);
            if (!res.ok) return null;
            return await res.text();
          }

          async function fetchLatestRelease(owner, repo) {
            const url = `${GH_API}/repos/${owner}/${repo}/releases/latest`;
            const res = await ghFetch(url);
            if (!res.ok) return null;
            return await res.json();
          }

          const skipReport = [];
          function skip(repo, reason) {
            skipReport.push({ repo, reason });
          }

          function hasRequiredFields(mod) {
            const required = ["Id", "name", "creator", "version", "teaser", "loader"];
            return required.every(k => typeof mod[k] === "string" && mod[k].trim() !== "");
          }

          function normalizeLoader(loader) {
            const l = String(loader).toLowerCase();
            if (l === "melon") return "melon";
            if (l === "bepinex") return "bepinex";
            if (l === "melon/bepinex" || l === "bepinex/melon") return "melon/bepinex";
            return null;
          }

          function parseGameVersions(gameVersion) {
            if (typeof gameVersion !== "string" || gameVersion.trim() === "") return null;
            const parts = gameVersion
              .split(",")
              .map(v => v.trim())
              .filter(v => v.length > 0);
            return parts.length > 0 ? parts : null;
          }

          function detectFinalLoader(baseLoader, assetName) {
            const name = assetName.toLowerCase();

            if (baseLoader === "melon" || baseLoader === "bepinex") {
              return baseLoader;
            }

            if (baseLoader === "melon/bepinex") {
              const hasBep = name.includes("bepinex_");
              const hasMelon = name.includes("melonloader_");

              if (hasBep && !hasMelon) return "bepinex";
              if (hasMelon && !hasBep) return "melon";

              return "both"; // ambiguous, include in both
            }

            return null;
          }

          async function safeDiscordSend(payload) {
            if (!webhook) return;
            let retries = 3;

            while (retries > 0) {
              const res = await fetch(webhook, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
              });

              if (res.status !== 429) return;

              const retryAfter = Number(res.headers.get("Retry-After")) || 2;
              await new Promise(r => setTimeout(r, retryAfter * 1000));
              retries--;
            }
          }

          async function sendDiscordEmbeds(embeds) {
            if (!webhook) return;
            for (let i = 0; i < embeds.length; i += 10) {
              const chunk = embeds.slice(i, i + 10);
              await safeDiscordSend({ embeds: chunk });
            }
          }

          function buildModEmbed(title, mod, color) {
            const embed = {
              title: title,
              description: `**${mod.name}** by ${mod.creator}`,
              url: `https://github.com/${mod.repo}`,
              color: color,
              timestamp: new Date().toISOString()
            };
            if (mod.icon) {
              embed.thumbnail = { url: mod.icon };
            }
            return embed;
          }

          function buildSkipEmbed(title, entry, color) {
            return {
              title: title,
              description: `\`${entry.repo}\`\n**Reason:** ${entry.reason}`,
              color: color,
              timestamp: new Date().toISOString()
            };
          }

          function loadJson(path, fallback) {
            try {
              if (fs.existsSync(path)) {
                const txt = fs.readFileSync(path, "utf8");
                return JSON.parse(txt);
              }
            } catch {}
            return fallback;
          }

          function mapByRepo(arr) {
            const map = new Map();
            for (const e of arr) {
              map.set(e.repo, e);
            }
            return map;
          }

          function diffMods(oldArr, newArr) {
            const oldMap = mapByRepo(oldArr);
            const newMap = mapByRepo(newArr);

            const added = [];
            const removed = [];
            const updated = [];

            for (const [repo, newEntry] of newMap.entries()) {
              if (!oldMap.has(repo)) {
                added.push(newEntry);
              } else {
                const oldEntry = oldMap.get(repo);
                if (JSON.stringify(oldEntry) !== JSON.stringify(newEntry)) {
                  updated.push(newEntry);
                }
              }
            }

            for (const [repo, oldEntry] of oldMap.entries()) {
              if (!newMap.has(repo)) {
                removed.push(oldEntry);
              }
            }

            return { added, removed, updated };
          }

          function diffSkips(oldArr, newArr) {
            const oldMap = mapByRepo(oldArr);
            const newMap = mapByRepo(newArr);

            const newlyBroken = [];
            const fixed = [];

            for (const [repo, newEntry] of newMap.entries()) {
              if (!oldMap.has(repo)) {
                newlyBroken.push(newEntry);
              }
            }

            for (const [repo, oldEntry] of oldMap.entries()) {
              if (!newMap.has(repo)) {
                fixed.push(oldEntry);
              }
            }

            return { newlyBroken, fixed };
          }

          (async () => {
            const repos = await getAllReposWithTopic(TOPIC);

            const melonMods = [];
            const bepinexMods = [];

            for (const repo of repos) {
              const owner = repo.owner.login;
              const name = repo.name;
              const branch = repo.default_branch;
              const repoKey = `${owner}/${name}`;

              const modJsonText = await fetchRawFile(owner, name, branch, "mod.json");
              if (!modJsonText) {
                skip(repoKey, "mod.json missing");
                continue;
              }

              let mod;
              try {
                mod = JSON.parse(modJsonText);
              } catch {
                skip(repoKey, "mod.json invalid JSON");
                continue;
              }

              if (!hasRequiredFields(mod)) {
                skip(repoKey, "required fields missing");
                continue;
              }

              const baseLoader = normalizeLoader(mod.loader);
              if (!baseLoader) {
                skip(repoKey, "invalid loader");
                continue;
              }

              const gameVersions = parseGameVersions(mod.gameVersion);
              if (!gameVersions) {
                skip(repoKey, "gameVersion missing");
                continue;
              }

              const release = await fetchLatestRelease(owner, name);
              if (!release || !Array.isArray(release.assets) || release.assets.length === 0) {
                skip(repoKey, "no valid release");
                continue;
              }

              const asset = release.assets[0];
              if (!asset.browser_download_url) {
                skip(repoKey, "release asset missing download URL");
                continue;
              }

              const iconTest = await fetchRawFile(owner, name, branch, "icon.png");
              const iconUrl = iconTest
                ? `https://raw.githubusercontent.com/${owner}/${name}/${branch}/icon.png`
                : null;

              let description = await fetchRawFile(owner, name, branch, "Description.md");
              if (!description) description = null;

              const finalLoader = detectFinalLoader(baseLoader, asset.name);
              if (!finalLoader) {
                skip(repoKey, "unable to determine loader type");
                continue;
              }

              const baseEntry = {
                repo: repoKey,
                id: mod.Id,
                name: mod.name,
                creator: mod.creator,
                version: mod.version,
                teaser: mod.teaser,
                gameVersion: gameVersions,
                description: description,
                tags: Array.isArray(mod.tags) ? mod.tags : [],
                icon: iconUrl,
                lastUpdated: release.published_at || release.created_at || repo.updated_at,
                githubStars: repo.stargazers_count || 0,
                download: asset.browser_download_url
              };

              if (finalLoader === "melon") {
                melonMods.push({ ...baseEntry, loader: "melon" });
              } else if (finalLoader === "bepinex") {
                bepinexMods.push({ ...baseEntry, loader: "bepinex" });
              } else if (finalLoader === "both") {
                melonMods.push({ ...baseEntry, loader: "melon" });
                bepinexMods.push({ ...baseEntry, loader: "bepinex" });
              }
            }

            if (!fs.existsSync(".github/history")) {
              fs.mkdirSync(".github/history", { recursive: true });
            }

            const oldMelon = loadJson(".github/history/melon-mods.old.json", []);
            const oldBep = loadJson(".github/history/bepinex-mods.old.json", []);
            const oldSkip = loadJson(".github/history/skip-report.old.json", []);

            const melonDiff = diffMods(oldMelon, melonMods);
            const bepDiff = diffMods(oldBep, bepinexMods);
            const skipDiff = diffSkips(oldSkip, skipReport);

            const embeds = [];
            
            function wasPreviouslyBroken(repo, oldSkipList) {
              return oldSkipList.some(e => e.repo === repo);
            }
            
            for (const mod of melonDiff.added) {
              if (!wasPreviouslyBroken(mod.repo, oldSkip)) {
                embeds.push(buildModEmbed("ðŸŸ¢ New Melon Mod", mod, 0x00ff00));
              }
            }

            for (const mod of bepDiff.added) {
              if (!wasPreviouslyBroken(mod.repo, oldSkip)) {
                embeds.push(buildModEmbed("ðŸŸ¢ New BepInEx Mod", mod, 0x00ff00));
              }
            }
            
            for (const mod of melonDiff.updated) {
              embeds.push(buildModEmbed("ðŸŸ¦ Updated Melon Mod", mod, 0x0000ff));
            }
            for (const mod of bepDiff.updated) {
              embeds.push(buildModEmbed("ðŸŸ¦ Updated BepInEx Mod", mod, 0x0000ff));
            }

            for (const mod of melonDiff.removed) {
              embeds.push(buildModEmbed("ðŸ”´ Removed Melon Mod", mod, 0xff0000));
            }
            for (const mod of bepDiff.removed) {
              embeds.push(buildModEmbed("ðŸ”´ Removed BepInEx Mod", mod, 0xff0000));
            }

            for (const entry of skipDiff.newlyBroken) {
              embeds.push(buildSkipEmbed("âš ï¸ New Broken Mod", entry, 0xffa500));
            }

            for (const entry of skipDiff.fixed) {
              const mod = melonMods.find(m => m.repo === entry.repo)
              || bepinexMods.find(m => m.repo === entry.repo);

              if (mod) {
                embeds.push(buildModEmbed("ðŸŸ¢ Fixed Mod (No Longer Skipped)", mod, 0x00ff00));
              }
            }

            if (embeds.length > 0) {
              await sendDiscordEmbeds(embeds);
            }

            fs.writeFileSync("melon-mods.json", JSON.stringify(melonMods, null, 2));
            fs.writeFileSync("bepinex-mods.json", JSON.stringify(bepinexMods, null, 2));
            fs.writeFileSync("skip-report.json", JSON.stringify(skipReport, null, 2));

            fs.writeFileSync(".github/history/melon-mods.old.json", JSON.stringify(oldMelon.length ? melonMods : melonMods, null, 2));
            fs.writeFileSync(".github/history/bepinex-mods.old.json", JSON.stringify(oldBep.length ? bepinexMods : bepinexMods, null, 2));
            fs.writeFileSync(".github/history/skip-report.old.json", JSON.stringify(oldSkip.length ? skipReport : skipReport, null, 2));
          })().catch(err => {
            console.error("Error building mod index:", err);
            process.exit(1);
          });
          EOF

      - name: Commit mod index
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add melon-mods.json bepinex-mods.json skip-report.json
          git add .github/history/melon-mods.old.json .github/history/bepinex-mods.old.json .github/history/skip-report.old.json
          git commit -m "Update mod index" || echo "No changes"
          git push
